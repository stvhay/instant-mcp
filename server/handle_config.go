package server

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"sort"

	"github.com/hays/instant-mcp/models"
	"gopkg.in/yaml.v3"
)

// importFile represents the YAML/JSON format for import/export
type importFile struct {
	Commands map[string]models.Command `json:"commands" yaml:"commands"`
}

func (s *Server) handleImportConfig(msg *JSONRPCMessage, params ToolsCallParams) error {
	path, _ := params.Arguments["path"].(string)
	if path == "" {
		return s.respondError(msg.ID, "path is required")
	}

	overwrite := false
	if ow, ok := params.Arguments["overwrite"].(bool); ok {
		overwrite = ow
	}

	data, err := os.ReadFile(path)
	if err != nil {
		return s.respondError(msg.ID, fmt.Sprintf("failed to read file: %v", err))
	}

	var file importFile

	// Try YAML first, then JSON
	if err := yaml.Unmarshal(data, &file); err != nil {
		if err := json.Unmarshal(data, &file); err != nil {
			return s.respondError(msg.ID, "failed to parse file as YAML or JSON")
		}
	}

	if len(file.Commands) == 0 {
		return s.respondError(msg.ID, "no commands found in file")
	}

	imported, skipped := 0, 0
	var errors []string

	for _, cmd := range file.Commands {
		existing, _ := s.registry.Get(cmd.Name)
		if existing.Name != "" && !overwrite {
			skipped++
			continue
		}

		var opErr error
		if existing.Name != "" {
			opErr = s.registry.Update(cmd.Name, cmd)
		} else {
			opErr = s.registry.Add(cmd)
		}

		if opErr != nil {
			errors = append(errors, fmt.Sprintf("%s: %v", cmd.Name, opErr))
		} else {
			imported++
		}
	}

	if imported > 0 {
		s.persist()
	}

	summary := fmt.Sprintf("Imported %d commands", imported)
	if skipped > 0 {
		summary += fmt.Sprintf(", skipped %d (already exist)", skipped)
	}
	if len(errors) > 0 {
		summary += fmt.Sprintf(", %d errors: %v", len(errors), errors)
	}

	log.Printf("Import from %s: %s", path, summary)
	return s.respondText(msg.ID, summary)
}

func (s *Server) handleExportConfig(msg *JSONRPCMessage, params ToolsCallParams) error {
	path, _ := params.Arguments["path"].(string)
	if path == "" {
		path = ".instant-mcp/commands.yaml"
	}

	cmds := s.registry.Snapshot()
	if len(cmds) == 0 {
		return s.respondError(msg.ID, "no commands to export")
	}

	file := importFile{Commands: cmds}

	data, err := yaml.Marshal(file)
	if err != nil {
		return s.respondError(msg.ID, fmt.Sprintf("failed to marshal YAML: %v", err))
	}

	// Add header comment
	header := "# instant-mcp commands\n# Generated by export_config\n# Import with: import_config(path: \"" + path + "\")\n\n"

	// Ensure directory exists
	dir := filepath.Dir(path)
	if dir != "." {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return s.respondError(msg.ID, fmt.Sprintf("failed to create directory: %v", err))
		}
	}

	if err := os.WriteFile(path, []byte(header+string(data)), 0644); err != nil {
		return s.respondError(msg.ID, fmt.Sprintf("failed to write file: %v", err))
	}

	// Sort command names for display
	names := make([]string, 0, len(cmds))
	for name := range cmds {
		names = append(names, name)
	}
	sort.Strings(names)

	log.Printf("Exported %d commands to %s", len(cmds), path)
	return s.respondText(msg.ID, fmt.Sprintf("Exported %d commands to %s: %v", len(cmds), path, names))
}
